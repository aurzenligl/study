#!/usr/bin/env python

import os
import sys
import argparse
from itertools import islice
import re
import dateutil.parser

__version__ = '0.1'

description = """\
     ;:,,,::::.                                                           
     +++++++++++                                                          
     ++++++++++#:                     Cuts                                
    `+++++++++++++#;,`                                                    
    ;+++++++++++++++:':+#+;:.`                                            
    ++++++++++++#+##+++: ..,.`.;+'+###+'';.:;''';;:.                      
   ;+++++++++++          `,';''++++++++';+;'+''+'++';;:;+;,.              
   ++++++++++++                     `:;+`;;;';;:::;;;''+#+'+';;'':.       
  +++++++++++++,                             ```,:;'+';';;';++#+'#';;;;,;;
 '+++++++++++++#          logs.                          :;'';''++;++';'+ 
.'++++++++++++++'                                             .;';;:',;'  
  ``.:;''''';:,.`                                                 .+''.   
"""

def emit_error(msg):
    sys.exit('hatchet' + ': error: ' + msg)

def parse_options():
    def potential_dir(name):
        if os.path.isfile(name):
            raise argparse.ArgumentTypeError("%s is an existing file" % name)
        return name

    def readable_file(name):
        if not os.path.isfile(name):
            raise argparse.ArgumentTypeError("%s file not found" % name)
        return name

    class ArgumentParser(argparse.ArgumentParser):
        def error(self, msg):
            emit_error(msg)

    parser = ArgumentParser('hatchet',
                            description=description,
                            formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('inputs',
                        type = readable_file,
                        nargs = '*',
                        help = ('Input in syslog or nodetime format.'))
    parser.add_argument('-v', '--version',
                        action = 'store_true',
                        help = 'Prints version.')
    parser.add_argument('-d', '--dir',
                        type = potential_dir,
                        help = 'Dir to split logs into by nodes.')
    parser.add_argument('-f', '--filter-nodes',
                        help = 'Regex to filter nodes.')
    parser.add_argument('-n', '--nodes',
                        action = 'store_true',
                        help = 'Prints nodes.')
    parser.add_argument('-s', '--stat',
                        type = int,
                        const = 0,
                        nargs = '?',
                        help = 'Prints statistics.')
    parser.add_argument('-nt', '--no-time',
                        action = 'store_true',
                        help = 'Does not print timestamps in output.')
    parser.add_argument('-nta', '--no-time-align',
                        action = 'store_true',
                        help = 'Does not align timestamps in output.')
    parser.add_argument('-nts', '--no-time-sort',
                        action = 'store_true',
                        help = 'Does not sort timestamps in output.')

    opts = parser.parse_args()
    if opts.version:
        sys.exit(__version__)
    if not opts.inputs:
        parser.print_help()
        sys.exit()
    return opts

def read_into_table(filenames, node_re):
    def check_file(filename):
        orig = '\d+\s+\d+.\d+\s+\d+:\d+:\d+.\d+\s+\[\d+.\d+.\d+.\d+\]\s+\w+\s+\S+\s+<[-:.TZ\d]*>\s+'
        nodetime = '\S+\s+<[-:.TZ\d]*>\s+'

        for line in islice(open(filename), 100):
            if re.match(orig, line):
                return 5

        for line in islice(open(filename), 100):
            if re.match(nodetime, line):
                return 0

        emit_error(filename + " has unknown format")

    lines = []
    pattern = re.compile('\s+')
    nodepat = node_re and re.compile(node_re)
    for filename in filenames:
        to_ignore = check_file(filename)
        for line in open(filename):
            elems = pattern.split(line, 2 + to_ignore)[to_ignore:]
            if elems:
                node, tst, log = elems
                if nodepat:
                    if not nodepat.search(node):
                        continue
                lines.append((node, tst, log.rstrip('\r\n')))
    return lines

def extract_nodes(lines):
    nodes = set()
    for node, _, _ in lines:
        nodes.add(node)
    return sorted(nodes)

def split_into_nodes(lines):
    nodes = {}
    for line in lines:
        node, _, _ = line
        nodes.setdefault(node, []).append(line)
    return nodes

def make_stat_nodes(lines):
    nodes = []
    for node, lines in sorted(split_into_nodes(lines).items(), key=lambda x: x[0]):
        times = sorted((tst.strip('<>') for _, tst, _ in lines if tst.startswith('<')))
        if times:
            nodes.append((node, sorted(times)))
    return nodes

def make_stat_rows(nodes, sort_col):
    def dpar(tst):
        return dateutil.parser.parse(tst)
    def ddur(dttd):
        return '{}.{:0>6}'.format(dttd.seconds, dttd.microseconds)

    cols = (
        [node for node, _ in nodes],
        [len(times) for _, times in nodes],
        [ddur(dpar(times[-1]) - dpar(times[0])) for _, times in nodes],
        [times[0] for _, times in nodes],
        [times[-1] for _, times in nodes]
    )

    maxlen = (
        max((len(str(node)) for node in cols[0])),
        max((len(str(logcount)) for logcount in cols[1])),
        max((len(str(duration)) for duration in cols[2])),
        len(cols[3][0]),
        len(cols[4][0])
    )

    sort_type = (str, int, float, str, str)

    rows = zip(*cols[:])
    if sort_col < len(sort_type):
        rows.sort(key=lambda x: sort_type[sort_col](x[sort_col]))

    fmt = "%%-%ss %%%ss %%%ss %%%ss %%%ss" % maxlen

    return rows, fmt

def sort_by_timestamp(lines):
    lines.sort(key=lambda x: x[1])

def lines_fmt(lines, with_node = True, time_align = True, with_time = True):
    def max_node_len(lines):
        return lines and max((len(node) for node, _, _ in lines)) or 0

    elems = []
    if with_node:
        if time_align:
            elems += ['{0:%ss}' % max_node_len(lines)]
        else:
            elems += ['{0}']
    if with_time:
        elems += ['{1}']
    elems += ['{2}']
    return ' '.join(elems) + '\n'

def write_lines(lines, fileobj, fmt):
    for node, tst, log in lines:
        fileobj.write(fmt.format(node, tst, log))

def do_nodes(lines):
    for node in extract_nodes(lines):
        print node

def do_stat(lines, sort_col):
    nodes = make_stat_nodes(lines)
    if nodes:
        rows, fmt = make_stat_rows(nodes, sort_col)
        for row in rows:
            print fmt % row

def do_dir(lines, outdir, time_sort, with_time):
    if not os.path.isdir(outdir):
        os.mkdir(outdir)
    for node, lines in split_into_nodes(lines).items():
        if time_sort:
            sort_by_timestamp(lines)
        output = open(os.path.join(outdir, node), 'w')
        fmt = lines_fmt(lines, with_node=False, with_time=with_time)
        write_lines(lines, output, fmt)

def do_stdout(lines, time_sort, time_align, with_time):
    if time_sort:
        sort_by_timestamp(lines)
    fmt = lines_fmt(lines, time_align=time_align, with_time=with_time)
    write_lines(lines, sys.stdout, fmt)

opts = parse_options()
lines = read_into_table(opts.inputs,
    node_re=opts.filter_nodes)
if opts.nodes:
    do_nodes(lines)
elif opts.stat is not None:
    do_stat(lines, opts.stat)
elif opts.dir:
    do_dir(lines, opts.dir,
        time_sort=not opts.no_time_sort,
        with_time=not opts.no_time)
else:
    do_stdout(lines,
        time_sort=not opts.no_time_sort,
        time_align=not opts.no_time_align,
        with_time=not opts.no_time)

"""
TODO:

1. stat histogram

node     logs seconds histogram        start timestamp             stop timestamp
ABC-1235 2342  988224 xx....x..x....xx 2016-04-19T11:46:36.124528Z 2016-04-19T11:46:36.124528Z
ABC-1235 2342  988224 ..........xxxXXX 2016-04-19T11:46:36.124528Z 2016-04-19T11:46:36.124528Z

2. filtering:

log
since
until

"""

