#!/usr/bin/env python

import os
import sys
import argparse
from itertools import islice
import re

description = """\
     ;:,,,::::.                                                           
     +++++++++++                                                          
     ++++++++++#:                     Cuts                                
    `+++++++++++++#;,`                                                    
    ;+++++++++++++++:':+#+;:.`                                            
    ++++++++++++#+##+++: ..,.`.;+'+###+'';.:;''';;:.                      
   ;+++++++++++          `,';''++++++++';+;'+''+'++';;:;+;,.              
   ++++++++++++                     `:;+`;;;';;:::;;;''+#+'+';;'':.       
  +++++++++++++,                             ```,:;'+';';;';++#+'#';;;;,;;
 '+++++++++++++#          logs.                          :;'';''++;++';'+ 
.'++++++++++++++'                                             .;';;:',;'  
  ``.:;''''';:,.`                                                 .+''.   
"""

def emit_error(msg):
    sys.exit('hatchet' + ': error: ' + msg)

def parse_options():
    def potential_dir(name):
        if os.path.isfile(name):
            raise argparse.ArgumentTypeError("%s is an existing file" % name)
        return name

    def readable_file(name):
        if not os.path.isfile(name):
            raise argparse.ArgumentTypeError("%s file not found" % name)
        return name

    class ArgumentParser(argparse.ArgumentParser):
        def error(self, msg):
            emit_error(msg)

    parser = ArgumentParser('hatchet',
                            description=description,
                            formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('inputs',
                        type = readable_file,
                        nargs = '*',
                        help = ('Input in syslog or nodetime format.'))
    parser.add_argument('-d', '--dir',
                        type = potential_dir,
                        help = 'Dir to split logs into by nodes.')
    parser.add_argument('-f', '--filter-nodes',
                        help = 'Regex to filter nodes.')
    parser.add_argument('-n', '--nodes',
                        action = 'store_true',
                        help = 'Prints nodes.')
    parser.add_argument('-s', '--stat',
                        action = 'store_true',
                        help = 'Prints statistics.')
    parser.add_argument('-nt', '--no-time',
                        action = 'store_true',
                        help = 'Does not print timestamps in output.')
    parser.add_argument('-nta', '--no-time-align',
                        action = 'store_true',
                        help = 'Does not align timestamps in output.')
    parser.add_argument('-nts', '--no-time-sort',
                        action = 'store_true',
                        help = 'Does not sort timestamps in output.')
    opts = parser.parse_args()
    if not opts.inputs:
        parser.print_help()
        sys.exit()
    return opts

def read_into_table(filenames):
    def check_file(filename):
        orig = '\d+\s+\d+.\d+\s+\d+:\d+:\d+.\d+\s+\[\d+.\d+.\d+.\d+\]\s+\w+\s+\S+\s+<[-:.TZ\d]*>\s+'
        nodetime = '\S+\s+<[-:.TZ\d]*>\s+'

        for line in islice(open(filename), 100):
            if re.match(orig, line):
                return 5

        for line in islice(open(filename), 100):
            if re.match(nodetime, line):
                return 0

        emit_error(filename + " has unknown format")

    lines = []
    pattern = re.compile('\s+')
    for filename in filenames:
        to_ignore = check_file(filename)
        for line in open(filename):
            elems = pattern.split(line, 2 + to_ignore)[to_ignore:]
            if elems:
                node, tst, log = elems
                lines.append((node, tst, log.rstrip('\r\n')))
    return lines

def extract_nodes(lines):
    nodes = set()
    for node, _, _ in lines:
        nodes.add(node)
    return sorted(nodes)

def split_into_nodes(lines):
    nodes = {}
    for line in lines:
        node, _, _ = line
        nodes.setdefault(node, []).append(line)
    return nodes

def sort_by_timestamp(lines):
    lines.sort(key=lambda x: x[1])

def lines_fmt(lines, with_node = True, time_align = True, with_time = True):
    def max_node_len(lines):
        return max((len(node) for node, _, _ in lines))

    elems = []
    if with_node:
        if time_align:
            elems += ['{0:%ss}' % max_node_len(lines)]
        else:
            elems += ['{0}']
    if with_time:
        elems += ['{1}']
    elems += ['{2}']
    return ' '.join(elems) + '\n'

def write_lines(lines, fileobj, fmt):
    for node, tst, log in lines:
        fileobj.write(fmt.format(node, tst, log))

def do_nodes(lines):
    for node in extract_nodes(lines):
        print node

def do_stat(lines):
    print "implement me..."

def do_dir(lines, outdir, time_sort, with_time):
    if not os.path.isdir(outdir):
        os.mkdir(outdir)
    for node, lines in split_into_nodes(lines).iteritems():
        if time_sort:
            sort_by_timestamp(lines)
        output = open(os.path.join(outdir, node), 'w')
        fmt = lines_fmt(lines, with_node=False, with_time=with_time)
        write_lines(lines, output, fmt)

def do_stdout(lines, time_sort, time_align, with_time):
    if time_sort:
        sort_by_timestamp(lines)
    fmt = lines_fmt(lines, time_align=time_align, with_time=with_time)
    write_lines(lines, sys.stdout, fmt)

opts = parse_options()
lines = read_into_table((opts.inputs))
if opts.nodes:
    do_nodes(lines)
elif opts.stat:
    do_stat(lines)
elif opts.dir:
    do_dir(lines, opts.dir,
        time_sort=not opts.no_time_sort,
        with_time=not opts.no_time)
else:
    do_stdout(lines,
        time_sort=not opts.no_time_sort,
        time_align=not opts.no_time_align,
        with_time=not opts.no_time)

"""
TODO:

1. stat

node      logs  seconds histogram        start timestamp               stop timestamp
ABC-1235  2342   988224 xx....x..x....xx <2016-04-19T11:46:36.124528Z> <2016-04-19T11:46:36.124528Z>
ABC-1235  2342   988224 ..........xxxXXX <2016-04-19T11:46:36.124528Z> <2016-04-19T11:46:36.124528Z>

2. filtering:

node
log
since
until

"""

